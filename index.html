<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Gleichungstrainer – mit Levels</title>

<style>
  body{
    font-family:system-ui,Arial,sans-serif;
    background:linear-gradient(to bottom right,#f0f4ff,#e0f7fa);
    text-align:center;
    margin:0;
    padding:16px;
    font-size:18px;
  }

  h1{
    color:#333;
    margin:8px 0 4px;
    font-size:1.8em;
  }

  #levelDisplay{
    font-weight:bold;
    color:#007bff;
    margin-top:4px;
  }

  #score{
    font-size:1em;
    margin:4px 0 8px;
    color:#333;
  }

  #progressContainer{
    width:80%;
    max-width:400px;
    height:20px;
    background-color:#ddd;
    border-radius:10px;
    margin:10px auto 16px;
    overflow:hidden;
    display:flex;
  }

  .progress-segment{
    flex:1;
    height:100%;
    background-color:#ddd;
    transition:background-color 0.3s ease;
  }

  .trainerBox{
    margin:0 auto;
    max-width:900px;
    background:#ffffffcc;
    border-radius:16px;
    padding:16px 18px 18px;
    text-align:left;
  }

  .rowLabel{
    font-weight:bold;
    color:#007bff;
    margin-bottom:4px;
  }

  .line{
    display:flex;
    align-items:center;
    gap:8px;
    margin-bottom:4px;
  }

  .eqFormLabel{
    font-size:1.3em;
    font-weight:bold;
  }

  .opInput{
    width:140px;
    padding:6px 8px;
    font-size:1.05em;
    border-radius:8px;
    border:1px solid #888;
    font-family:monospace;
  }

  .solutionInput{
    flex:1;
    max-width:200px;
    padding:6px 8px;
    font-size:1.05em;
    border-radius:8px;
    border:1px solid #888;
    font-family:monospace;
  }

  .checkBtn{
    background:#007bff;
    color:white;
    border:none;
    padding:7px 12px;
    border-radius:8px;
    cursor:pointer;
    font-size:0.95em;
    white-space:nowrap;
  }

  .checkBtn:hover{
    background:#0056b3;
  }

  .fb{
    font-size:0.95em;
    min-height:1.2em;
    margin:2px 0 8px;
  }

  .ok{color:#2e7d32;}
  .err{color:#c62828;}

  /* ---------- Level 1 Layout ---------- */

  .eqTextL1{
    font-family:monospace;
    font-size:1.4em;
    font-weight:bold;
    flex:0 1 auto;
    margin-right:4px;
  }

  .lineL1{
    gap:4px;
  }

  .eqSign{
    font-size:1.4em;
    font-weight:bold;
  }

  .eqSolLeft{
    font-family:monospace;
    font-size:1.2em;
  }

  /* ---------- Level 2 ---------- */

  #level2Box{
    display:none; /* Start mit Level 1 */
  }

  .eqRow2{
    margin-bottom:14px;
  }

  .eqDisplay{
    text-align:center;
    font-family:monospace;
    font-size:1.4em;
    font-weight:bold;
  }

  #solutionSet{
    font-size:1.2em;
    font-weight:bold;
    color:#007bff;
    margin-top:6px;
    text-align:left;
    visibility:hidden;
  }

  #footerNote{
    font-size:0.8em;
    color:#555;
    margin-top:32px;
  }

  #nextWrapper{
    margin-top:10px;
    text-align:center;
  }

  #nextBtn{
    padding:10px 22px;
    font-size:1.05em;
    border:none;
    background:#007bff;
    color:white;
    border-radius:10px;
    cursor:pointer;
  }

  #nextBtn:hover{
    background:#0056b3;
  }
</style>
</head>
<body>

<h1>Gleichungstrainer</h1>
<div id="levelDisplay">Level 1: einfache Gleichungen</div>
<div id="score">Aufgabe 1 von 10 – Punkte: 0</div>
<div id="progressContainer"></div>

<!-- ---------- Level 1 UI ---------- -->
<div id="level1Box" class="trainerBox">

  <div class="rowLabel">1. Umformungsschritt</div>
  <div class="line lineL1">
    <span id="equationTextL1" class="eqTextL1">Lade Gleichung …</span>
    <span class="eqFormLabel">|</span>
    <input type="text" id="opInputL1" class="opInput" placeholder="+5, -3, :4, *3 …">
    <button id="opCheckBtnL1" class="checkBtn">Umformung prüfen</button>
  </div>
  <div id="opFbL1" class="fb"></div>

  <div>
    <div class="rowLabel">2. Lösungszeile</div>
    <div class="line">
      <span class="eqSolLeft">x</span>
      <span class="eqSign">=</span>
      <input type="text" id="solInputL1" class="solutionInput" placeholder="Zahl">
      <button id="solCheckBtnL1" class="checkBtn">Lösung prüfen</button>
    </div>
    <div id="solFbL1" class="fb"></div>
  </div>
</div>

<!-- ---------- Level 2 UI ---------- -->
<div id="level2Box" class="trainerBox">
  <div class="eqRow2">
    <div id="equationL2" class="eqDisplay">Lade Gleichung …</div>
  </div>

  <div>
    <div class="rowLabel">1. Umformungsschritt</div>
    <div class="line">
      <span class="eqFormLabel">|</span>
      <input type="text" id="opInputL2" class="opInput" placeholder="-x, +3x, +5, -7, :4 …">
      <button id="opCheckBtnL2" class="checkBtn">Umformung prüfen</button>
    </div>
    <div id="opFbL2" class="fb"></div>
  </div>

  <div>
    <div class="rowLabel">2. Lösungszeile (z.B. x = 2)</div>
    <div class="line">
      <input type="text" id="solInputL2" class="solutionInput" placeholder="x = …">
      <button id="solCheckBtnL2" class="checkBtn">Lösung prüfen</button>
    </div>
    <div id="solFbL2" class="fb"></div>
  </div>

  <div id="solutionSet">L = { ? }</div>
</div>

<div id="nextWrapper">
  <button id="nextBtn">Neue Aufgabe</button>
</div>

<p id="footerNote">
Diese Seite speichert keine persönlichen Daten und läuft vollständig lokal im Browser.<br>
© 2025 Gleichungstrainer mit Levelsystem
</p>

<script>
document.addEventListener("DOMContentLoaded", () => {

  /* ---------- DOM ---------- */

  const levelDisplay  = document.getElementById("levelDisplay");
  const scoreEl       = document.getElementById("score");
  const progressContainer = document.getElementById("progressContainer");

  const level1Box = document.getElementById("level1Box");
  const level2Box = document.getElementById("level2Box");
  const nextBtn   = document.getElementById("nextBtn");

  // Level 1
  const eqTextL1   = document.getElementById("equationTextL1");
  const opInputL1  = document.getElementById("opInputL1");
  const opFbL1     = document.getElementById("opFbL1");
  const solInputL1 = document.getElementById("solInputL1");
  const solFbL1    = document.getElementById("solFbL1");
  const opCheckBtnL1  = document.getElementById("opCheckBtnL1");
  const solCheckBtnL1 = document.getElementById("solCheckBtnL1");

  // Level 2
  const equationL2   = document.getElementById("equationL2");
  const opInputL2    = document.getElementById("opInputL2");
  const opFbL2       = document.getElementById("opFbL2");
  const solInputL2   = document.getElementById("solInputL2");
  const solFbL2      = document.getElementById("solFbL2");
  const opCheckBtnL2  = document.getElementById("opCheckBtnL2");
  const solCheckBtnL2 = document.getElementById("solCheckBtnL2");
  const solutionSet   = document.getElementById("solutionSet");

  /* ---------- Level/Progress ---------- */

  const TOTAL_ROUNDS = 10;
  const MAX_LEVEL = 2;

  let level = 1;
  let round = 1;
  let score = 0;

  // pro Aufgabe:
  let hasSolutionCheck = false;
  let lastSolutionCorrect = false;

  const segments = [];

  function initProgressBar(){
    progressContainer.innerHTML = "";
    segments.length = 0;
    for(let i=0;i<TOTAL_ROUNDS;i++){
      const seg = document.createElement("div");
      seg.className = "progress-segment";
      seg.style.backgroundColor = "#ddd";
      progressContainer.appendChild(seg);
      segments.push(seg);
    }
  }

  function updateScoreLabel(){
    scoreEl.textContent = `Aufgabe ${Math.min(round, TOTAL_ROUNDS)} von ${TOTAL_ROUNDS} – Punkte: ${score}`;
    if(level === 1){
      levelDisplay.textContent = "Level 1: einfache Gleichungen";
    }else{
      levelDisplay.textContent = "Level 2: lineare Gleichungen";
    }
  }

  function applyProgressForCurrentTask(){
    const idx = round - 1;
    const seg = segments[idx];
    if(!seg) return;

    if(lastSolutionCorrect){
      seg.style.backgroundColor = "#4caf50";
      // Punkt nur einmal zählen
      score++;
    }else{
      seg.style.backgroundColor = "#d9534f";
    }
  }

  function switchToNextLevelOrRestart(){
    if(level < MAX_LEVEL){
      alert(`Level ${level} beendet.\nPunkte: ${score} von ${TOTAL_ROUNDS}.\nWeiter mit Level ${level+1}.`);
      level++;
    }else{
      alert(`Level ${level} beendet.\nPunkte: ${score} von ${TOTAL_ROUNDS}.\nEs geht wieder mit Level 1 los.`);
      level = 1;
    }

    round = 1;
    score = 0;
    initProgressBar();
    updateScoreLabel();

    if(level === 1){
      level1Box.style.display = "block";
      level2Box.style.display = "none";
    }else{
      level1Box.style.display = "none";
      level2Box.style.display = "block";
    }

    newTaskForCurrentLevel();
  }

  /* ---------- Helper ---------- */

  function setFb(el,text,isOk){
    el.textContent = text;
    el.className = "fb " + (isOk ? "ok" : "err");
  }

  function normalizeOpString(str){
    return str
      .replace(/\s+/g,"")
      .replace(",",".")
      .replace(/·/g,"*")
      .replace(/−/g,"-");
  }

  function parseSolutionValue(str){
    const s = str.replace(/\s+/g,"");
    if(!s) return null;
    const m = s.match(/-?\d+/);
    if(!m) return null;
    return parseInt(m[0],10);
  }

  function randInt(min,max){
    return Math.floor(Math.random()*(max-min+1))+min;
  }

  /* =========================================================
     LEVEL 1 – einfache Gleichungen (4 Grundformen)
     ========================================================= */

  // A: x + a = b   oder   a + x = b    → -a
  // B: x - a = b                      → +a
  // C: x·a = b   oder   a·x = b       → :a
  // D: x / a = b   oder x : a = b     → *a

  let currentEqL1 = null;   // { kind, a, solution, eqText, expectedOp }

  function generateEquationL1(){
    const kinds = ["add","sub","mult","div"];
    const kind = kinds[randInt(0,kinds.length-1)];

    let lhs, rhs, solution, a, expectedOp;

    if(kind === "add"){
      a = randInt(1,20);
      solution = randInt(-10,10);
      rhs = solution + a;
      const xFirst = Math.random() < 0.5;
      lhs = xFirst ? `x + ${a}` : `${a} + x`;
      expectedOp = {type:"-", value:a};
    }else if(kind === "sub"){
      a = randInt(1,20);
      solution = randInt(-10,10);
      rhs = solution - a;
      lhs = `x - ${a}`;
      expectedOp = {type:"+", value:a};
    }else if(kind === "mult"){
      a = randInt(2,10);
      solution = randInt(-10,10);
      rhs = solution * a;
      const xFirst = Math.random() < 0.5;
      lhs = xFirst ? `x · ${a}` : `${a} · x`;
      expectedOp = {type:":", value:a};
    }else{ // div
      a = randInt(2,10);
      const rhsVal = randInt(-10,10);
      solution = rhsVal * a;
      const useColon = Math.random() < 0.5;
      lhs = useColon ? `x : ${a}` : `x / ${a}`;
      rhs = rhsVal;
      expectedOp = {type:"*", value:a};
    }

    const eqText = `${lhs} = ${rhs}`;
    return {kind,a,solution:eqTextSolution(solution),numericSolution:solution,eqText,expectedOp};

    function eqTextSolution(sol){ return sol; } // Platzhalter für evtl. spätere Format-Änderungen
  }

  function parseOpL1(str){
    const s = normalizeOpString(str);
    if(!s) return null;
    const type = s[0];
    if(!"+-*/:".includes(type)) return null;
    const numStr = s.slice(1);
    const val = parseFloat(numStr);
    if(!isFinite(val) || val === 0) return null;
    return {type, value: val};
  }

  function opsEqualL1(user, expected){
    if(!user || !expected) return false;
    const normType = t => (t === "/" ? ":" : t === "·" ? "*" : t);
    const ut = normType(user.type);
    const et = normType(expected.type);
    return ut === et && Math.abs(user.value - expected.value) < 1e-9;
  }

  let lastOpCorrectL1 = false;

  function newTaskL1(){
    currentEqL1 = generateEquationL1();
    eqTextL1.textContent = currentEqL1.eqText;

    opInputL1.value = "";
    solInputL1.value = "";
    opFbL1.textContent = "";
    opFbL1.className = "fb";
    solFbL1.textContent = "";
    solFbL1.className = "fb";

    lastOpCorrectL1 = false;
    hasSolutionCheck = false;
    lastSolutionCorrect = false;
    solutionSet.style.visibility = "hidden"; // betrifft Level 2, schadet aber nicht

    opInputL1.focus();
  }

  function checkOpLevel1(){
    if(!currentEqL1){
      setFb(opFbL1,"Keine Aufgabe geladen.",false);
      return;
    }
    const u = parseOpL1(opInputL1.value);
    if(!u){
      setFb(opFbL1,"Bitte z.B. +5, -3, :4 oder *3 eingeben.",false);
      lastOpCorrectL1 = false;
      return;
    }
    if(opsEqualL1(u,currentEqL1.expectedOp)){
      setFb(opFbL1,"Das ist die richtige Umformung!",true);
      lastOpCorrectL1 = true;
    }else{
      setFb(opFbL1,"Das ist nicht die richtige Umformung.",false);
      lastOpCorrectL1 = false;
    }
  }

  function checkSolutionLevel1(){
    if(!currentEqL1){
      setFb(solFbL1,"Keine Aufgabe geladen.",false);
      return;
    }
    const val = parseSolutionValue(solInputL1.value);
    if(val === null){
      setFb(solFbL1,"Bitte nur die Zahl für x eingeben.",false);
      return;
    }
    const correct = (val === currentEqL1.numericSolution);
    hasSolutionCheck = true;
    lastSolutionCorrect = correct;

    if(correct){
      setFb(solFbL1,"Lösung korrekt!",true);
    }else{
      setFb(solFbL1,"Diese Lösung ist nicht korrekt.",false);
    }
  }

  /* =========================================================
     LEVEL 2 – lineare Gleichungen mit inhaltlicher Prüfung
     ========================================================= */

  let currentEqL2Obj = null;  // {equation, solution}

  function normalizeMinus2(s){ return s.replace(/−/g,"-"); }

  function parseSide(str){
    str = normalizeMinus2(str).replace(/\s+/g,"");
    if(str==="") return {cx:0,c0:0};
    if(!["+","-"].includes(str[0])) str = "+"+str;
    const terms = str.match(/[+\-][^+\-]+/g) || [];
    let cx=0,c0=0;
    for(const t of terms){
      const sign = t[0]==="-"?-1:1;
      const body=t.slice(1);
      if(body.includes("x")){
        const cs = body.replace("x","");
        const coeff = cs===""?1:parseFloat(cs);
        cx += sign*coeff;
      }else{
        const n=parseFloat(body);
        if(!isNaN(n)) c0 += sign*n;
      }
    }
    return {cx,c0};
  }

  function canonEq(eq){
    const [L,R] = eq.split("=");
    const pL = parseSide(L);
    const pR = parseSide(R);
    return {ax:pL.cx-pR.cx, b:pL.c0-pR.c0};
  }

  function solveCanon(c){
    if(c.ax === 0) return null;
    return -c.b/c.ax;
  }

  function formatLinear(coeff, constant){
    let left = "";
    if(coeff === 1){
      left += "x";
    }else if(coeff === -1){
      left += "-x";
    }else{
      left += coeff+"x";
    }
    if(constant > 0){
      left += " + " + constant;
    }else if(constant < 0){
      left += " - " + Math.abs(constant);
    }
    return left;
  }

  function generateEquationL2(){
    let x0;
    do{x0 = randInt(-5,5);}while(x0===0);

    let A;
    do{A = randInt(-6,6);}while(A===0);

    const stage = randInt(1,3); // 1: x-Terme, 2: Zahlen, 3: Division
    let equation;

    if(stage === 1){
      let C;
      do{C = randInt(-6,6);}while(C===0 || C===A);
      const B = randInt(-10,10);
      const D = A*x0 + B - C*x0;
      const left  = formatLinear(A,B);
      const right = formatLinear(C,D);
      equation = `${left} = ${right}`;
    }else if(stage === 2){
      const B = randInt(-10,10) || 3;
      const D = A*x0 + B;
      const left = formatLinear(A,B);
      const right = String(D);
      equation = `${left} = ${right}`;
    }else{
      const D = A * x0;
      let left;
      if(A === 1){
        left = "x";
      }else if(A === -1){
        left = "-x";
      }else{
        left = `${A}x`;
      }
      const right = String(D);
      equation = `${left} = ${right}`;
    }

    return {equation, solution:x0};
  }

  function parseUserOpL2(raw){
    let s = normalizeOpString(raw);
    if(!s) return null;

    const type = s[0];
    if(!"+-:/".includes(type)) return null;
    let body = s.slice(1);
    if(!body) return null;

    let hasX = false;
    if(body.includes("x")){
      hasX = true;
      body = body.replace("x","");
    }

    if(body === "") body = "1";
    if(body === "+" || body === "-") body += "1";

    const val = parseFloat(body);
    if(!isFinite(val) || val === 0) return null;

    return {type, val, hasX};
  }

  function expectedOpForEquation(eqStr){
    const [Lstr, Rstr] = eqStr.split("=");
    const L = parseSide(Lstr);
    const R = parseSide(Rstr);

    const hasLx = (L.cx !== 0);
    const hasRx = (R.cx !== 0);

    // x-Terme auf eine Seite
    if(hasLx && hasRx){
      let del;
      if(L.cx < R.cx){
        del = -L.cx;
      }else{
        del = -R.cx;
      }
      if(del === 0) return null;
      return {
        type: (del > 0 ? "+" : "-"),
        val: Math.abs(del),
        hasX: true
      };
    }

    // Zahlen auf die andere Seite
    if(hasLx || hasRx){
      const side = hasLx ? L : R;
      if(side.c0 !== 0){
        const del = -side.c0;
        return {
          type: (del > 0 ? "+" : "-"),
          val: Math.abs(del),
          hasX: false
        };
      }
    }

    // Division durch x-Koeffizient
    const side = hasLx ? L : (hasRx ? R : null);
    if(side && side.cx !== 0 && side.c0 === 0){
      return {
        type: ":",
        val: side.cx,
        hasX: false
      };
    }

    return null;
  }

  function opsEqualL2(user, expected){
    if(!user || !expected) return false;

    const normType = t => (t === "/" ? ":" : t);
    const ut = normType(user.type);
    const et = normType(expected.type);

    if(ut !== et) return false;
    if(user.hasX !== expected.hasX) return false;

    if(ut === "+" || ut === "-"){
      return Math.abs(user.val - expected.val) < 1e-9;
    }

    if(ut === ":"){
      return Math.abs(user.val - expected.val) < 1e-9;
    }

    return false;
  }

  let lastOpCorrectL2 = false;

  function newTaskL2(){
    currentEqL2Obj = generateEquationL2();
    equationL2.textContent = currentEqL2Obj.equation;

    opInputL2.value = "";
    solInputL2.value = "";
    opFbL2.textContent = "";
    solFbL2.textContent = "";
    opFbL2.className = "fb";
    solFbL2.className = "fb";
    solutionSet.style.visibility = "hidden";
    solutionSet.textContent = "L = { ? }";

    lastOpCorrectL2 = false;
    hasSolutionCheck = false;
    lastSolutionCorrect = false;

    opInputL2.focus();
  }

  function checkOpLevel2(){
    if(!currentEqL2Obj){
      setFb(opFbL2,"Keine Aufgabe geladen.",false);
      return;
    }

    const u = parseUserOpL2(opInputL2.value);
    if(!u){
      setFb(opFbL2,"Bitte eine sinnvolle Umformung eingeben (z.B. -x, +3x, +5 oder :4).",false);
      lastOpCorrectL2 = false;
      return;
    }

    const exp = expectedOpForEquation(currentEqL2Obj.equation);
    if(!exp){
      setFb(opFbL2,"Für diese Gleichung kann ich keine passende Umformung erkennen.",false);
      lastOpCorrectL2 = false;
      return;
    }

    if(opsEqualL2(u,exp)){
      setFb(opFbL2,"Das ist die richtige Umformung!",true);
      lastOpCorrectL2 = true;
    }else{
      setFb(opFbL2,"Das ist nicht die richtige Umformung für den nächsten Schritt!",false);
      lastOpCorrectL2 = false;
    }
  }

  function checkSolutionLevel2(){
    if(!currentEqL2Obj){
      setFb(solFbL2,"Keine Aufgabe geladen.",false);
      return;
    }
    const val = parseSolutionValue(solInputL2.value);
    if(val === null){
      setFb(solFbL2,"Bitte eine Lösung in der Form x = Zahl eingeben (hier reicht die Zahl).",false);
      return;
    }
    const correct = (val === currentEqL2Obj.solution);
    hasSolutionCheck = true;
    lastSolutionCorrect = correct;

    if(correct){
      setFb(solFbL2,"Lösung korrekt!",true);
      solutionSet.style.visibility = "visible";
      solutionSet.textContent = `L = { ${currentEqL2Obj.solution} }`;
    }else{
      setFb(solFbL2,"Diese Lösung ist nicht korrekt.",false);
    }
  }

  /* ---------- Aufgabenwechsel ---------- */

  function newTaskForCurrentLevel(){
    if(level === 1){
      newTaskL1();
    }else{
      newTaskL2();
    }
  }

  nextBtn.addEventListener("click", () => {
    if(!hasSolutionCheck){
      alert("Bitte prüfe zuerst deine Lösung, bevor du zur nächsten Aufgabe gehst.");
      return;
    }

    // Fortschrittsbalken für aktuelle Aufgabe aktualisieren
    applyProgressForCurrentTask();
    updateScoreLabel();

    if(round >= TOTAL_ROUNDS){
      switchToNextLevelOrRestart();
    }else{
      round++;
      updateScoreLabel();
      newTaskForCurrentLevel();
    }
  });

  /* ---------- Events ---------- */

  // Level 1
  opCheckBtnL1.addEventListener("click", checkOpLevel1);
  solCheckBtnL1.addEventListener("click", checkSolutionLevel1);
  opInputL1.addEventListener("keydown", e=>{ if(e.key==="Enter") checkOpLevel1(); });
  solInputL1.addEventListener("keydown", e=>{ if(e.key==="Enter") checkSolutionLevel1(); });

  // Level 2
  opCheckBtnL2.addEventListener("click", checkOpLevel2);
  solCheckBtnL2.addEventListener("click", checkSolutionLevel2);
  opInputL2.addEventListener("keydown", e=>{ if(e.key==="Enter") checkOpLevel2(); });
  solInputL2.addEventListener("keydown", e=>{ if(e.key==="Enter") checkSolutionLevel2(); });

  /* ---------- Start: immer bei Level 1 ---------- */
  initProgressBar();
  level = 1;
  round = 1;
  score = 0;
  updateScoreLabel();
  level1Box.style.display = "block";
  level2Box.style.display = "none";
  newTaskForCurrentLevel();

});
</script>

</body>
</html>
